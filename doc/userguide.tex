\documentclass[12pt]{article}

\usepackage{amsmath}
\usepackage[margin=1in]{geometry}

\newcommand{\phimin}{\phi_{\rm min}}
\newcommand{\phimax}{\phi_{\rm max}}
\newcommand{\thetamin}{\theta_{\rm min}}
\newcommand{\thetamax}{\theta_{\rm max}}
\newcommand{\phiminp}{\phi_{\rm min}^\prime}
\newcommand{\phimaxp}{\phi_{\rm max}^\prime}
\newcommand{\thetaminp}{\theta_{\rm min}^\prime}
\newcommand{\thetamaxp}{\theta_{\rm max}^\prime}

\begin{document}

\begin{titlepage} % Suppresses displaying the page number on the title page and the subsequent page counts as page 1
	\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Defines a new command for horizontal lines, change thickness here
	
	\center % Centre everything on the page
	
	%------------------------------------------------
	%	Headings
	%------------------------------------------------
	
	%\textsc{\LARGE Institution Name}\\[1.5cm] % Main heading such as the name of your university/college
	
	%\textsc{\Large Major Heading}\\[0.5cm] % Major heading such as course name
	
	%\textsc{\large Minor Heading}\\[0.5cm] % Minor heading such as course title
	
	%------------------------------------------------
	%	Title
	%------------------------------------------------
	
	\HRule\\[0.4cm]
	
	{\huge\bfseries TERESA: Three-dimensional Exoplanet Retrieval from Eclipse Spectroscopy of Atmospheres (name not final)}\\[0.4cm] % Title of your document
	
	\HRule\\[1.5cm]
	
	%------------------------------------------------
	%	Author(s)
	%------------------------------------------------
	
	%% \begin{minipage}{0.4\textwidth}
	%% 	\begin{flushleft}
	%% 		\large
	%% 		\textit{Author}\\
	%% 		Ryan C. \textsc{Challener} % Your name
	%% 	\end{flushleft}
	%% \end{minipage}
	%% ~
	%% \begin{minipage}{0.4\textwidth}
	%% 	\begin{flushright}
	%% 		\large
	%% 		\textit{Supervisor}\\
	%% 		Emily \textsc{Rauscher} % Supervisor's name
	%% 	\end{flushright}
	%% \end{minipage}
	
	% If you don't want a supervisor, uncomment the two lines below and comment the code above
	{\large\textit{Author}}\\
	\textsc{Ryan C. Challener} % Your name
	
	%------------------------------------------------
	%	Date
	%------------------------------------------------
	
	\vfill\vfill\vfill % Position the date 3/4 down the remaining page
	
	{\large\today} % Date, change the \today to a set date if you want to be precise
	
	%------------------------------------------------
	%	Logo
	%------------------------------------------------
	
	%\vfill\vfill
	%\includegraphics[width=0.2\textwidth]{placeholder.jpg}\\[1cm] % Include a department/university logo - this will require the graphicx package
	 
	%----------------------------------------------------------------------------------------
	
	\vfill % Push the date up 1/4 of the remaining page
	
\end{titlepage}

\section{Overview}

The goal of this package is to retrieve the three-dimensional atmosphere 
of an exoplanet from spectroscopic eclipse observations. It builds upon
the work of Rauscher et al., 2018, where they use principal component
analysis of light curves generated from spherical harmonic maps to
determine a set of orthogonal light curves (``eigencurves''). These
eigencurves are linearly combined to produce a best-fitting light-curve
model, which is then converted to a temperature map.

This code constructs these temperature maps for each spectroscopic
light curve and then places them vertically within the atmosphere. It
then runs a radiative transfer calculation to produce planetary
emission as a function of location on the planet. The emission is
integrated over the wavelength filters and combined with the visibility
function to create light curves to compare against the data. This
calculation is put behind a Markov-chain Monte Carlo (MCMC) to explore
parameter space.

The code is split into two operating modes: 2D and 3D. These modes are
described in detail in the following sections. 

\section{2D Mode}

\subsection{Constructing 2D Maps}

The ``2D'' mode of the code constructs the 2-dimensional thermal maps
which are used in the ``3D'' mode. Hence, the code must be run in 2D
before attempting a 3D fit.

First, the code calculates light curves from positive and negative
spherical harmonics maps, up to a user-supplied complexity
($l_{\textrm{max}}$). Then, these harmonics light curves are run
through a principle component analysis (PCA) to determine a set of
orthogonal light curves (``eigencurves''), ordered by importance. The
eigencurves are linearly combined with the uniform-map stellar and
planetary light curves and fit, individually, to the spectroscopic
light curves. That is, the same set of eigencurves are used for each
spectroscopic bin, but they are allowed different
weights. Functionally, the model is the following:

\begin{equation}
  F_{\textrm{sys}}(t) = c_0 Y_0^0 + \sum_i^N c_i E_i + F_{\textrm{star}} + s_{\textrm{corr}},
\end{equation}

\noindent
where $F_{\textrm{sys}}$ is the system flux, $N$ is the number of
eigencurves to use (set by the user), $c_i$ are the eigencurve
weights, $E_i$ are the eigencurves, $Y_0^0$ is the light curve of the
uniform-map planet, $F_{\textrm{star}}$ is the light curve of the star
(like constant and equal to unity, if the data are normalized), and
$s_{\textrm{corr}}$ is a constant stellar flux correction term to
ensure that when the planet is eclipsed, the system flux matches the
stellar flux.

This model is fit to each spectroscopic light curve using a
least-squares minimization algorithm. Optionally, the user may specify
that emitted fluxes must be positive. Negative fluxes are problematic
because they are non-physical, and imply a negative temperature, which
will cause problems for any attempts to run radiative transfer, a
necessary step in 3D fitting. If this option is enabled, the model
includes a check for positive fluxes; if negatives are found, the
model returns a very poor fit, forcing the fit toward physically
plausible thermal maps. Note that the code only enforces this
condition on visible grid cells of the planet. Although the flux maps
are defined on non-visible grid cells, this is only due to the
continuity enforced by spherical harmonics. In reality, non-visible
cells are completely unconstrained.

The code then uses the $c_i$ weights along with the ``eigenmaps''
that match the eigencurves to compute a single flux map for each input
light curve (Equation 4 of Rauscher et al., 2018):

\begin{equation}
  Z_p(\theta, \phi) = c_0 Y_0^0(\theta, \phi) + \sum_i^Nc_iZ_i(\theta, \phi),
\end{equation}

\noindent
where $Z_p$ is the flux map, $\theta$ is latitude, $\phi$ is longitude,
and $Z_i$ are the eigenmaps.

These flux maps are converted to temperature maps using Equation 8 of
Rauscher et al., 2018 (here we have included the stellar correction
term as described in the appendix):

\begin{equation}
  T_p(\theta, \phi) = (hc / \lambda k) / \textrm{ln} \left[1 + \left(\frac{R_p}{R_s}\right)^2 \frac{\textrm{exp}[hc/\lambda k T_s] - 1}{\pi Z_p(\theta, \phi) (1 + s_{\textrm{corr}})}\right],
\end{equation}

\noindent
where $\lambda$ is the band-averaged wavelength of the filter used to observe
the related light curve, $R_p$ is the radius of the planet, $R_s$ is the
radius of the star, and $T_s$ is the stellar temperature.

\subsection{The Visibility Function}

The 2D mode also computes the visibility function, which describes the
visibility of each grid cell on the planet as a function of
time. There are two sources of reduced visibility: line-of-sight
(reduced visibility toward the limb) and the star. Thus,

\begin{equation}
  V(\theta, \phi, t) = L(\theta, \phi, t) S(\theta, \phi, t),
\end{equation}

\noindent
where $V$ is the visibility, $L$ is line-of-sight visibility, and $S$
is visibility due to the star. We define $\theta$ and $\phi$ to be
locations on the planet with respect to the observer. As the planet
revolves, the ``sub-observer'' point ($\theta = 0$, $\phi = 0$) moves
in true latitude and longitude. The $\theta$ and $\phi$ of each grid
cell change with time, but the cells' latitudes and longitudes are
constant.

Line-of-sight visibility depends primarily on angular distance from
the point on the planet closest to the observer. However, the planet is
subdivided into discrete grid cells, which are likely large due
to runtime considerations. Hence, a significant portion of the planet's
flux may come from grid cells near the limb, which are only
partially visibile. Therefore, we include a term to adjust these limb
cells to only account for the visible portion of the cell. $L$ is
then

\begin{equation}
  L(\theta, \phi, t) = \cos\bar\theta \cos\bar\phi A_{\textrm{corr}},
\end{equation}

\noindent
where $\bar\theta$ is the average visible $\theta$, $\bar\phi$ is the
average visible $\phi$, and $A_{\textrm{corr}}$ is the area correction
term. If we define ($\phi_{\rm min}$, $\phi_{\rm max}$) as the range
of latitudes of a grid cell, ($\theta_{\rm min}$, $\theta_{\rm max}$)
as the range of longitudes of a grid cell, and the primed versions as
the corresponding \textit{visible} ranges, then

\begin{align}
  A_{\textrm{corr}} &= \frac{A_{\textrm{partial}}}{A_{\textrm{full}}}\\
  &= \frac{\int_{\phiminp}^{\phimaxp}\int_{\thetaminp}^{\thetamaxp}\cos\theta d\theta d\phi}{\int_{\phimin}^{\phimax}\int_{\thetamin}^{\thetamax}\cos\theta d\theta d\phi}\\
  &= \left(\frac{\phimaxp - \phiminp}{\phimax - \phimin}\right)\left(\frac{\sin\thetamaxp - \sin\thetaminp}{\sin\thetamax - \sin\thetamin}\right).
\end{align}

\noindent
For fully-visible grid cells, $A_{\rm corr}$ = 1.

Stellar visibility is the crux of eclipse mapping. As the planet moves
behind the star, it is gradually eclipsed, from west to east, and then
vice versa when the planet reemerges. Different grid cells are visible
at different times, which enables disentangling the emission of each
grid cell from the planetary emission as a whole. Currently, the
code uses a very simple form of stellar visibility, where a grid cell
is flagged as 100\% visible or 0\% visible depending on its location
projected onto the plane perpendicular to the observer's line
of sight. In functional form,

\begin{equation*}
  S(\theta, \phi, t)=\begin{cases}
    0 \quad &\text{if}\, d < R_s \\
    1 \quad &\text{otherwise} \\
  \end{cases}
\end{equation*}

\noindent
where $d$ is the projected distance between the center of the visible
portion of the grid cell and the center of the star, defined as

\begin{align}
  d &= \sqrt{(x_{\rm cell} - x_s)^2 + (y_{\rm cell} - y_s)^2} \\
  &= \sqrt{(x_p + R_p \cos\bar\theta\sin\bar\phi - x_s)^2 + (y_p + R_p \sin\bar\theta - y_s)^2}.
\end{align}

\noindent
$x_p$ is the $x$ position of the planet, $x_s$ is the $x$ position of the
star, $y_p$ is the $y$ position of the planet, and $y_s$ is the $y$
position of the star.

We compute $L$ and $S$ for every grid cell at every time in the
observation.  Later, in the 3D operating mode, this precomputed
visibility grid is multiplied with the planetary emitted flux and then
summed over the grid cells at each time to compute the spectroscopic
light curves.

\section{3D Mode}

The 3D portion of the code places the 2D thermal maps vertically
in the planet's atmosphere, generates an atmospheric composition,
runs radiative transfer on each grid cell, integrates the emergent
flux over the observation filters, combines the flux with the
visibility function, and integrates over the planet to calculate
spectroscopic light curves for comparison to the data. The process
is done thousands to millions of times behind an MCMC algorithm
to accurately estimate parameter uncertainties.

\subsection{Temperature-Pressure Mapping Functions}

The manner in which the thermal maps are placed vertically in the
atmosphere is one of the most important choices in the 3D model.
The following options are currently available:

\begin{itemize}
\item Interpolate/Extrapolate -- Assigns each 2D thermal map to a
  location-independent pressure, then linearly interpolates the
  temperature-pressure (TP) profiles in each grid cell in
  log(pressure) space. Pressure layers above and below the 2D thermal
  maps are assigned extrapolated temperatures. This can cause
  negative or extremely high temperatures, so use with caution.

\item Interpolate/Isothermal -- The same as Interpolate/Extrapolate,
  except pressure layers above and the below the 2D thermal maps,
  where interpolation is impossible, are instead set to the same
  temperature as the closest (in pressure) 2D thermal map.
\end{itemize}

\subsection{Atmospheric Composition}

The code also generates an atmospheric composition, as atomic and
molecular abundances vs.\ pressure for each grid cell. Currently
the only option is thermochemical equilibrium using the \texttt{rate}
package. In theory, more complex schemes are possible, including
options to fit to atmospheric composition.

\subsection{Radiative Transfer}

Once the temperature and compositional structure of the atmosphere are
set, the code runs radiative transfer to calculate the emergent flux
from each grid cell. The following radiative transfer packages are
available:

\begin{itemize}
\item Tau-REx 3 -- https://github.com/ucl-exoplanets/TauREx3\_public/
\end{itemize}

For the sake of efficiency, radiative transfer is only run on grid
cells which are visible at some point during the observation. This
also prevents problems when negative temperatures are present on the
non-visible portions of the planet. If negative temperatures are found
in any visible grid cells, the code will return negative fluxes, which
should always be a worse fit than any physical fluxes, thereby driving
any fitting or MCMC algorithm toward non-negative temperatures.

The emergent flux from each grid cell is then integrated over the
observation filters and combined with the visibility function to
generate light curves for comparison to the data.

\subsection{MCMC}

The light-curve model function, described above, is run within an MCMC
to explore parameter space and accurately estimate parameter
uncertainties.  The MCMC is done through MC3
(https://github.com/pcubillos/MC3), which offers 3 sampling
algorithms: Metropolis-Hastings random walk, Differential Evolutions
Markov-chain Monte Carlo, and ``snooker''.

\section{User Interface}

The code is executed from the command line with the following commands:

\begin{verbatim}
./run.py 2d example.cfg
./run.py 3d example.cfg
\end{verbatim}

\noindent
to run the 2D and 3D operating modes, respectively. The 3rd command-line
argument (``example.cfg'' above) points to a configuration file, in
ConfigParser format, which allows the user to supply a wide array
of options to the code.

\subsection{Configuration File}

The configuration file follows the ConfigParser format, a standard
Python format. Options are separated into several different categories
(e.g., ``General'', ``Star'', ``Planet'', etc.). The following options
are available:

\begin{itemize}
\item General options:
  \begin{itemize}
  \item outdir -- The name of the directory where output will be saved. 
    
  \item lmax -- The maximum $l$ value of the spherical harmonic maps
    which are used to generate the eigencurves and eigenmaps used in
    the 2D operating mode. Increasing (decreasing) this value will
    result in more (less) complex eigenmaps. Must be an integer.

  \item plots -- A boolean flag to make plots. Turning this off can
    reduce runtimes.

  \item animations -- A boolean flag to make animations. Turning this off
    can significantly reduce runtimes.

  \item ncurves -- The number of eigencurves to use in the 2D fits. A
    higher number of curves increases the complexity of the fit. A
    Bayesian Information Criterion comparison between fits with
    different values for ncurves can tell you how many eigencurves are
    warranted. The maximum value of ncurves is (lmax+1)$^2$, although
    using more than (lmax+1)$^2$/2 is not advised as there will be
    significant correlations between positive and negative versions of
    the same eigencurve.

  \item ncpu -- The number of parallel processes to use in MCMC. Setting
    this higher will make the code run faster, up to a limit based on your
    hardware.

  \item nsamples -- The number of iterations in the MCMC. Should be
    large enough to ensure that the MCMC has converged.

  \item burnin -- The number of iterations that are discarded from the
    start of each chain. Should be much less than nsamples / nchains.

  \item leastsq -- The type of least-squares algorithm to use when
    performing minimization.

  \item timefile -- A path to the file which contains a single column of
    the times of the observations.

  \item fluxfile -- A path to the file which contains a column of fluxes for
    each spectroscopic light curve.

  \item ferrfile -- A path to the file which contains a column of flux
    unvertainties for each spectroscopic light curve.

  \item atmtype -- Type of atmosphere. Options are: ``eq''
    (thermochemical equilibrium).

  \item nlayers -- Number of pressure layers in the atmosphere. They will
    be calculated in log(pressure) space.

  \item ptop -- The pressure at the top of the atmosphere, in bars.

  \item pbot -- The pressure at the bottom of the atmosphere, in bars.

  \item res -- The number of planetary grid cells in latitude and
    longitude.  For example, res = 9 will create a grid of 81 cells,
    with widths of 40$^\circ$ and heights of 20$^\circ$.

  \item posflux -- A boolean instructing the code to enforce a
    positive-flux condition. If true, the 2D maps will be required to
    have positive emission in every grid cell that is visible at any
    point during the observation.

  \item elemfile -- A path to a file containing solar elemental abundances.
    Currently unused, but may be necessary for future radiative transfer
    packages.

  \item filtfiles -- A list of paths to files describing filter
    transmission.  Files must have two columns: wavelength in microns
    and filter transmission. Transmission need not be normalized, as
    the filters will be normalized prior to integration.

  \item mapfunc -- The TP mapping function that links
    2D maps to pressures in each grid cell. Current options are: ``constant''
    (each 2D map is placed at a single, constant pressure).

  \item oob -- ``Out-of-bounds'' behavior of the TP mapping function, if
    applicaable. Options are: ``iso'' (isothermal) or ``extrapolate''.

  \item rtfunc -- The radiative transfer package to use. Current
    options are: ``taurex''.
  \end{itemize}
\item Star options
  \begin{itemize}
  \item m -- Stellar mass in solar masses.

  \item r -- Stellar radius in solar radii.

  \item prot -- Stellar rotation period in days.

  \item t -- Stellar temperature in Kelvin.

  \item d -- Distance to the star in parsec.

  \item z -- Metallicity relative to solar.
  \end{itemize}
\item Planet options
  \begin{itemize}
  \item m -- Planetary mass in solar masses.

  \item r -- Planetary radius in solar radii.

  \item porb -- Planetary orbital period in days.

  \item prot -- Planetary rotation period in days.

  \item Omega -- Planetary longitude of the ascending node in degrees.

  \item ecc -- Planetary eccentricity.

  \item inc -- Planetary inclination in degrees (90 is edge-on).

  \item b -- Planetary impact parameter.

  \item a -- Planetary semi-major axis in AU.

  \item t0 -- Time of transit in days.
  \end{itemize}
\item Tau-REx options
  \begin{itemize}
  \item csxdir -- Directory containing molecular cross-section opacities.

    \item ciadir -- Directory containing collision-induced absoprtion
      opacities.

    \item wnlow -- Minimum wavenumber (/cm) to use in the radiative transfer.
      Reducing the wavenumber range of the radiative transfer can significantly
      reduce runtimes, but be sure that your filters are fully included.

    \item wnhigh -- Maximum wavenumber (/cm) to use in the radiative transfer.
      Reducing the wavenumber range of the radiative transfer can significantly
      reduce runtimes, but be sure that your filters are fully included.

    \item wndelt -- Resolution of the wavenumber grid. Tau-REx doesn't seem
      to actually use this.

    \item mols -- Molecules which will be included in the opacities. Other
      molecules will be put in the atmosphere, but will be assumed to have
      0 opacity. Reducing molecules can significantly decrease runtimes,
      but may ignore important opacity sources.
  \end{itemize}
\end{itemize}


\end{document}
